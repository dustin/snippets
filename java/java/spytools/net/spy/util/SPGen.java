// Copyright (c) 2001  Dustin Sallings <dustin@spy.net>
//
// $Id: SPGen.java,v 1.10 2002/08/23 00:13:17 dustin Exp $

package net.spy.util;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.PrintWriter;

import java.util.Iterator;
import java.util.StringTokenizer;
import java.util.ArrayList;

/**
 * Generator for .spt-&gt;.java.
 */
public class SPGen extends Object {

	private BufferedReader in=null;
	private PrintWriter out=null;
	private String classname=null;

	private String section="";
	private String description="";
	private String procname="";
	private String pkg="";
	private String superclass="DBSP";
	private String version="$Revision: 1.10 $";
	private long cachetime=0;
	private ArrayList sqlquery=null;
	private ArrayList required=null;
	private ArrayList optional=null;
	private ArrayList results=null;

	/**
	 * Get a new SPGen from the given BufferedReader.
	 */
	public SPGen(String classname, BufferedReader in, PrintWriter out) {
		super();
		this.in=in;
		this.out=out;
		this.classname=classname;
		sqlquery=new ArrayList();
		required=new ArrayList();
		optional=new ArrayList();
		results=new ArrayList();
	}

	public void generate() throws Exception {
		parse();
		write();
	}

	private void write() throws Exception {
		System.out.println("Writing out " + pkg + "." + classname);
		// Copyright info
		out.println(
			"// Copyright (c) 2001  SPY internetworking <dustin@spy.net>\n"
		    + "// Written by Dustin's SQL generator version " + version +"\n"
			+ "//\n"
			+ "// $" + "Id" + "$\n");

		// Package info
		out.println("package " + pkg + ";\n");

		// Imports
		out.println("import java.sql.Types;\n"
			+ "import java.sql.Connection;\n"
			+ "import java.sql.SQLException;\n"
			+ "import net.spy.db." + superclass + ";\n"
			+ "import net.spy.SpyConfig;\n");

		// Generate the documentation.
		out.println("/**\n"
			+ " * \n"
			+ " * " + description + "\n"
			+ " *\n"
			+ " * <p>\n"
			+ " *\n"
			+ " * Generated by SPGen version " + version + " on "
				+ new java.util.Date() + "\n"
			+ " *\n"
			+ " * <p>\n"
			+ " *");
		if(superclass.equals("DBSP")) {
			out.println(" * <b>Procedure Name</b>\n"
				+ " *\n"
				+ " * <ul>\n"
				+ " *  <li>" + procname + "</li>\n"
				+ " * </ul>");
		} else {
			out.println(" * <b>SQL Query</b>\n"
				+ " *\n"
				+ " * <ul>\n"
				+ " " + getDocQuery() + "\n"
				+ " * </ul>");
		}

		// Required parameters
		out.println(" *\n"
			+ " * <b>Required Parameters</b>\n"
			+ " * <ul>");
		if(required.size()==0) {
			out.println(" *  <li><i>none</i></li>");
		} else {
			for(Iterator i=required.iterator(); i.hasNext(); ) {
				Parameter p=(Parameter)i.next();
				out.println(" * <li>" + p.getName() + " - "
					+ p.getType() + " - " + p.getDescription() + "</li>");
			}
		}
		out.println(" * </ul>\n"
			+ " *\n"
			+ " * <p>\n"
			+ " *");

		// Optional parameters
		out.println(" *\n"
			+ " * <b>Optional Parameters</b>\n"
			+ " * <ul>");
		if(optional.size()==0) {
			out.println(" *  <li><i>none</i></li>");
		} else {
			for(Iterator i=optional.iterator(); i.hasNext(); ) {
				Parameter p=(Parameter)i.next();
				out.println(" * <li>" + p.getName() + " - "
					+ p.getType() + " - " + p.getDescription() + "</li>");
			}
		}
		out.println(" * </ul>\n"
			+ " *\n"
			+ " * <p>\n"
			+ " *");

		out.println(" */\n");

		// Actual code generation
		out.println("public class " + classname + " extends "
			+ superclass + " {\n");

		// Next constructor
		out.println("\tpublic " + classname + "(SpyConfig conf) "
			+ "throws SQLException {\n"
			+ "\t\t// Super constructor\n"
			+ "\t\tsuper(conf);\n"
			+ "\t\tspinit();\n"
			+ "\t}\n");

		// Next constructor
		out.println("\tpublic " + classname + "(Connection conn) "
			+ "throws SQLException {\n"
			+ "\t\t// Super constructor\n"
			+ "\t\tsuper(conn);\n"
			+ "\t\tspinit();\n"
			+ "\t}\n");

		// Initializer
		out.println("\tprivate void spinit() {");
		// Figure out whether we're a DBSP or a DBSQL
		if(superclass.equals("DBSP")) {
			out.println("\t\t// Set the stored procedure name\n"
				+ "\t\tsetSPName(\"" + procname + "\");");
		} else {
			out.println("\t\t// Set the SQL\n"
				+ "\t\t" + getJavaQuery()
				+ "\n\t\tsetQuery(query.toString());");
		}
		// Set the required parameters
		if(required.size() > 0) {
			out.println("\n\t\t// Set the required parameters.");
			for(Iterator i=required.iterator(); i.hasNext(); ) {
				Parameter p=(Parameter)i.next();
				out.println("\t\tsetRequired(\"" + p.getName() + "\", "
					+ "Types." + p.getType() + ");");
			}
		}
		// Set the optional parameters
		if(optional.size() > 0) {
			out.println("\n\t\t// Set the optional parameters.");
			for(Iterator i=required.iterator(); i.hasNext(); ) {
				Parameter p=(Parameter)i.next();
				out.println("\t\tsetOptional(\"" + p.getName() + "\", "
					+ "Types." + p.getType() + ");");
			}
		}
		// Set the cachetime, if there is one
		if(cachetime>0) {
			out.println("\n\t\t// Set the default cache time.");
			out.println("\t\tsetCacheTime(" + cachetime + ");");
		}

		out.println("\t}\n");
		out.println("}");

	}

	private String getDocQuery() {
		StringBuffer sb=new StringBuffer(1024);

		sb.append(" * <pre>\n");
		for(Iterator i=sqlquery.iterator(); i.hasNext(); ) {
			String part=(String)i.next();
			sb.append(" * ");
			sb.append(part);
			sb.append("\n");
		}
		sb.append(" * </pre>\n");

		return(sb.toString().trim());
	}

	private String getJavaQuery() {
		StringBuffer sb=new StringBuffer(1024);

		sb.append("\n\t\tStringBuffer query=new StringBuffer(1024);");

		for(Iterator i=sqlquery.iterator(); i.hasNext(); ) {
			String part=(String)i.next();
			sb.append("\n\t\tquery.append(\"");

			for(StringTokenizer st=new StringTokenizer(part, "\"", true);
				st.hasMoreTokens(); ) {

				String tmp=st.nextToken();
				if(tmp.equals("\"")) {
					tmp="\\\"";
				}
				sb.append(tmp);
			}

			sb.append("\\n\");");
		}

		return(sb.toString().trim());
	}

	private void parse() throws Exception {

		System.out.println("Parsing " + classname + ".spt");

		String tmp=in.readLine();
		while(tmp!=null) {

			// Don't do anything if the line is empty
			if(tmp.length() > 0) {
				if(tmp.charAt(0) == '@') {
					section=tmp.substring(1);
					// System.out.println("Working on section " + section);
				} else if(tmp.charAt(0) == '#') {
					// Comment, ignore
				} else {

					if(section.equals("description")) {
						description+=tmp;
					} else if(section.equals("sql")) {
						sqlquery.add(tmp);
						superclass="DBSQL";
					} else if(section.equals("procname")) {
						procname+=tmp;
						superclass="DBSP";
					} else if(section.equals("params")) {
						Parameter param=new Parameter(tmp);
						if(param.isRequired()) {
							required.add(param);
						} else {
							optional.add(param);
						}
					} else if(section.equals("results")) {
					} else if(section.equals("package")) {
						pkg+=tmp;
					} else if(section.equals("cachetime")) {
						cachetime=Long.parseLong(tmp);
					} else {
						throw new Exception("Unknown section:  " + section);
					}

				}
			}

			tmp=in.readLine();
		}
	}

	// Private class for parameters

	private class Parameter extends Object {
		private String name=null;
		private boolean required=false;
		private String type=null;
		private String description=null;

		public Parameter(String line) throws Exception {
			super();

			StringTokenizer st=new StringTokenizer(line, " \t");
			try {
				name=st.nextToken();
			} catch (java.util.NoSuchElementException ex) {
				// ASSERT: this theoretically should never happen,
				// otherwise how did we end up here in the first place?
				throw new Exception ("Missing parameter name! "
					+ex.toString());
			}

			String tmp=null;
			try {
				tmp=st.nextToken();
			} catch (java.util.NoSuchElementException ex) {
				// at this point you have forgotten to add in the parameter
				// of whether or not the parameter is required/optional.  I
				// guess a default could be applied here, but I'm just
				// gonna throw an Exception.
				throw new Exception ("Missing parameter requirement! "
					+ex.toString());
			}

			if(tmp.equals("required")) {
				required=true;
			} else if(tmp.equals("optional")) {
				required=false;
			} else {
				throw new Exception(
					"Parameter must be required or optional, not "
					+ tmp + " like in " + line);
			}

			try {
				type=st.nextToken();
			} catch (java.util.NoSuchElementException ex) {
				// now the variable type is missing  That's no good, you
				// need a speficic type ya know.
				throw new Exception ("Missing parameter type! "
					+ex.toString());
			}

			try {
				// This character pretty much can't be in the line.
				description=st.nextToken("\n");
			} catch (java.util.NoSuchElementException ex) {
				// I don't think we cre if it's documented or not!  But
				// honestly I don't think this should ever happen cause you
				// need a newline.  Well, I guess if you ended the file odd
				// enough, and without a EOL before the EOF...very odd case
				description="";
			}
		}

		public String getName() {
			return(name);
		}

		public String getType() {
			return(type);
		}

		public String getDescription() {
			return(description);
		}

		public boolean isRequired() {
			return(required);
		}
	}

	/**
	 * Usage:  SPGen filename
	 */
	public static void main(String args[]) throws Exception {

		String infile=args[0];
		// Get rid of the .spt
		int lastslash=infile.lastIndexOf(File.separatorChar);
		String basename=infile.substring(0, infile.indexOf(".spt"));
		// If it matches, start at the next character, if it didn't, it's
		// -1 and start at 0
		String classname=basename.substring(lastslash+1);
		String outfile=basename + ".java";

		BufferedReader in=new BufferedReader(new FileReader(infile));
		PrintWriter out=new PrintWriter(new FileWriter(outfile));
		SPGen spg=new SPGen(classname, in, out);

		spg.generate();

		in.close();
		out.close();
	}

}
